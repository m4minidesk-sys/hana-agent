#!/usr/bin/env python3
"""Generate Slack icon images using Amazon Bedrock Nova Canvas."""

import argparse
import base64
import json
import os
import sys
from pathlib import Path
from typing import Optional

import boto3
import yaml
from botocore.exceptions import ClientError


def load_presets() -> dict:
    """Load preset definitions from icon_presets.yaml."""
    preset_file = Path(__file__).parent / "icon_presets.yaml"
    try:
        with open(preset_file) as f:
            data = yaml.safe_load(f)
            return data.get("presets", {})
    except FileNotFoundError:
        return {}


def generate_icons(
    prompt: str,
    output_dir: str,
    count: int = 3,
    size: int = 1024,
    seed: Optional[int] = None,
    quality: str = "premium",
    negative: Optional[str] = None,
    cfg_scale: float = 8.0,
) -> None:
    """Generate icons using Bedrock Nova Canvas API."""
    # Create output directory
    os.makedirs(output_dir, exist_ok=True)
    
    # Create Bedrock client
    client = boto3.client("bedrock-runtime", region_name="us-east-1")
    
    # Prepare request body
    body = {
        "taskType": "TEXT_IMAGE",
        "textToImageParams": {
            "text": prompt,
        },
        "imageGenerationConfig": {
            "numberOfImages": count,
            "height": size,
            "width": size,
            "cfgScale": cfg_scale,
            "quality": quality,
        },
    }
    
    if negative:
        body["textToImageParams"]["negativeText"] = negative
    
    if seed is not None:
        body["imageGenerationConfig"]["seed"] = seed
    
    # Call Bedrock API
    try:
        response = client.invoke_model(
            modelId="amazon.nova-canvas-v1:0",
            body=json.dumps(body),
        )
    except ClientError as e:
        print(f"Bedrock API error: {e}", file=sys.stderr)
        print("\nTroubleshooting:", file=sys.stderr)
        print("- Check AWS credentials are configured", file=sys.stderr)
        print("- Verify Bedrock model access in us-east-1", file=sys.stderr)
        print("- Ensure IAM permissions for bedrock:InvokeModel", file=sys.stderr)
        sys.exit(1)
    
    # Parse response
    result = json.loads(response["body"].read())
    images = result.get("images", [])
    
    if not images:
        print("Error: No images generated by API", file=sys.stderr)
        sys.exit(1)
    
    # Save images
    seed_value = seed if seed is not None else 0
    try:
        for idx, img_base64 in enumerate(images):
            img_data = base64.b64decode(img_base64)
            filename = f"yui-icon-{seed_value}-{idx}.png"
            filepath = Path(output_dir) / filename
            
            with open(filepath, "wb") as f:
                f.write(img_data)
            
            file_size = len(img_data)
            print(f"Saved: {filepath} ({file_size} bytes)")
    except (IOError, OSError) as e:
        print(f"File write error: {e}", file=sys.stderr)
        sys.exit(1)


def main():
    """CLI entry point."""
    parser = argparse.ArgumentParser(
        description="Generate Slack icon images using Amazon Bedrock Nova Canvas"
    )
    
    # Prompt and preset arguments (manual mutual exclusivity)
    parser.add_argument(
        "--prompt",
        type=str,
        help="Image generation prompt",
    )
    parser.add_argument(
        "--preset",
        type=str,
        help="Use preset prompt (use 'list' to show available presets)",
    )
    
    parser.add_argument(
        "--negative",
        type=str,
        help="Negative prompt (things to avoid)",
    )
    parser.add_argument(
        "--count",
        type=int,
        default=3,
        choices=range(1, 6),
        help="Number of images to generate (1-5, default: 3)",
    )
    parser.add_argument(
        "--size",
        type=int,
        default=1024,
        choices=[512, 1024, 2048],
        help="Image size in pixels (512/1024/2048, default: 1024)",
    )
    parser.add_argument(
        "--seed",
        type=int,
        help="Random seed for reproducibility",
    )
    parser.add_argument(
        "--quality",
        type=str,
        default="premium",
        choices=["standard", "premium"],
        help="Image quality (standard/premium, default: premium)",
    )
    parser.add_argument(
        "--output-dir",
        type=str,
        default="assets/icons",
        help="Output directory (default: assets/icons)",
    )
    parser.add_argument(
        "--cfg-scale",
        type=float,
        default=8.0,
        help="CFG scale for prompt adherence (default: 8.0)",
    )
    
    args = parser.parse_args()
    
    # Manual validation for mutually exclusive arguments
    if args.prompt and args.preset:
        parser.error("--prompt and --preset are mutually exclusive, cannot use both")
    
    if not args.prompt and not args.preset:
        parser.error("one of the arguments --prompt --preset is required")
    
    # Handle preset list
    if args.preset == "list":
        presets = load_presets()
        print("Available presets:")
        for name in presets.keys():
            print(f"  - {name}")
        sys.exit(0)
    
    # Load preset if specified
    if args.preset:
        presets = load_presets()
        if args.preset not in presets:
            print(f"Error: Preset '{args.preset}' not found", file=sys.stderr)
            print("\nAvailable presets:", file=sys.stderr)
            for name in presets.keys():
                print(f"  - {name}", file=sys.stderr)
            sys.exit(1)
        
        preset = presets[args.preset]
        prompt = preset["prompt"]
        negative = preset.get("negative", args.negative)
        cfg_scale = preset.get("cfg_scale", args.cfg_scale)
    else:
        prompt = args.prompt
        negative = args.negative
        cfg_scale = args.cfg_scale
    
    # Generate icons
    generate_icons(
        prompt=prompt,
        output_dir=args.output_dir,
        count=args.count,
        size=args.size,
        seed=args.seed,
        quality=args.quality,
        negative=negative,
        cfg_scale=cfg_scale,
    )


if __name__ == "__main__":
    main()
